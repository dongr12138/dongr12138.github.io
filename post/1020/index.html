<!DOCTYPE html>
<html lang="en-us">
<head>
  <meta charset="utf-8">
  <meta http-equiv="x-ua-compatible" content="ie=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="author" content="rui">
  <meta name="description" content="我不接受批评，你如果说我，我就骂你">
  <meta name="generator" content="Hugo 0.58.3" />

  <title>1020-Springboot入门 &middot; Maybe...</title>

  <link rel="shortcut icon" href="https://dongr12138.github.io/images/favicon.ico">
  <link rel="stylesheet" href="https://dongr12138.github.io/css/spectre.min.css">
  <link rel="stylesheet" href="https://dongr12138.github.io/css/style.css">
  <link rel="stylesheet" href="https://dongr12138.github.io/css/highlight.css">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css">
  
    <link rel="stylesheet" href="https://cdn.rawgit.com/konpa/devicon/df6431e323547add1b4cf45992913f15286456d3/devicon.min.css">
  

  
    <link href="" rel="alternate" type="application/rss+xml" title="Maybe..." />
  

  
  <meta property="og:title" content="1020-Springboot入门" />
<meta property="og:description" content="该怎么去形容你最贴切，拿什么跟你比较才算特别。 &ndash;蔡健雅《红色高跟鞋》 01：22
一、Spring Boot 入门 1、Spring Boot 简介  简化Spring应用开发的一个框架；
整个Spring技术栈的一个大整合；
J2EE开发的一站式解决方案；
 2、微服务 2014，martin fowler
微服务：架构风格（服务微化）
一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；
单体应用：ALL IN ONE
微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；
详细参照微服务文档
3、环境准备 http://www.gulixueyuan.com/ 谷粒学院
环境约束
–jdk1.8：Spring Boot 推荐jdk1.7及以上；java version &ldquo;1.8.0_112&rdquo;
–maven3.x：maven 3.3以上版本；Apache Maven 3.3.9
–IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS
–SpringBoot 1.5.9.RELEASE：1.5.9；
统一环境；
1、MAVEN设置； 给maven 的settings.xml配置文件的profiles标签添加
&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt;  2、IDEA设置 整合maven进来；
4、Spring Boot HelloWorld 一个功能：
浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；
1、创建一个maven工程；（jar） 2、导入spring boot相关的依赖 &lt;parent&gt; &lt;groupId&gt;org." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://dongr12138.github.io/post/1020/" />
<meta property="article:published_time" content="2019-10-20T20:15:13+08:00" />
<meta property="article:modified_time" content="2019-10-20T20:15:13+08:00" />

  
  <meta itemprop="name" content="1020-Springboot入门">
<meta itemprop="description" content="该怎么去形容你最贴切，拿什么跟你比较才算特别。 &ndash;蔡健雅《红色高跟鞋》 01：22
一、Spring Boot 入门 1、Spring Boot 简介  简化Spring应用开发的一个框架；
整个Spring技术栈的一个大整合；
J2EE开发的一站式解决方案；
 2、微服务 2014，martin fowler
微服务：架构风格（服务微化）
一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；
单体应用：ALL IN ONE
微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；
详细参照微服务文档
3、环境准备 http://www.gulixueyuan.com/ 谷粒学院
环境约束
–jdk1.8：Spring Boot 推荐jdk1.7及以上；java version &ldquo;1.8.0_112&rdquo;
–maven3.x：maven 3.3以上版本；Apache Maven 3.3.9
–IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS
–SpringBoot 1.5.9.RELEASE：1.5.9；
统一环境；
1、MAVEN设置； 给maven 的settings.xml配置文件的profiles标签添加
&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt;  2、IDEA设置 整合maven进来；
4、Spring Boot HelloWorld 一个功能：
浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；
1、创建一个maven工程；（jar） 2、导入spring boot相关的依赖 &lt;parent&gt; &lt;groupId&gt;org.">


<meta itemprop="datePublished" content="2019-10-20T20:15:13&#43;08:00" />
<meta itemprop="dateModified" content="2019-10-20T20:15:13&#43;08:00" />
<meta itemprop="wordCount" content="1095">



<meta itemprop="keywords" content="" />

  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="1020-Springboot入门"/>
<meta name="twitter:description" content="该怎么去形容你最贴切，拿什么跟你比较才算特别。 &ndash;蔡健雅《红色高跟鞋》 01：22
一、Spring Boot 入门 1、Spring Boot 简介  简化Spring应用开发的一个框架；
整个Spring技术栈的一个大整合；
J2EE开发的一站式解决方案；
 2、微服务 2014，martin fowler
微服务：架构风格（服务微化）
一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；
单体应用：ALL IN ONE
微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；
详细参照微服务文档
3、环境准备 http://www.gulixueyuan.com/ 谷粒学院
环境约束
–jdk1.8：Spring Boot 推荐jdk1.7及以上；java version &ldquo;1.8.0_112&rdquo;
–maven3.x：maven 3.3以上版本；Apache Maven 3.3.9
–IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS
–SpringBoot 1.5.9.RELEASE：1.5.9；
统一环境；
1、MAVEN设置； 给maven 的settings.xml配置文件的profiles标签添加
&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt;  2、IDEA设置 整合maven进来；
4、Spring Boot HelloWorld 一个功能：
浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；
1、创建一个maven工程；（jar） 2、导入spring boot相关的依赖 &lt;parent&gt; &lt;groupId&gt;org."/>

</head>

<body onload="setPixelFont()">
  <div class="container p-fixed" style="z-index:3">
  <nav class="navbar m-2 p-2 s-rounded shadow bg-primary">
    <section class="navbar-section">
      <button class="btn btn-action btn-primary s-circle text-gray" id="pixelfont-toggle"><i class="fas fa-robot fa-lg"></i></button>
    </section>
    <section class="navbar-section">
      
        <a class="btn btn-primary" href='https://dongr12138.github.io/'>Home</a>
      

      

      
      <a class="btn btn-accent" href="" target="_blank"><i class="fas fa-rss fa-lg"></i></a>
      
    </section>
  </nav>
</div>

  <section class="container grid-md">
  <div class="columns">
    
    
<article class="container p-centered mt-space">
  <header>
    <h2 class="text-center">1020-Springboot入门</h2>
    <h6 class="text-gray text-italic"></h6>
  </header>
  <section class="my-gap">
    

<p><em><u>该怎么去形容你最贴切，拿什么跟你比较才算特别。          &ndash;蔡健雅《红色高跟鞋》</u></em> <em>01：22</em></p>

<h1 id="一-spring-boot-入门-u"><strong><em>一、Spring Boot 入门</u></em></strong></h1>

<h2 id="1-spring-boot-简介">1、Spring Boot 简介</h2>

<blockquote>
<p>简化Spring应用开发的一个框架；</p>

<p>整个Spring技术栈的一个大整合；</p>

<p>J2EE开发的一站式解决方案；</p>
</blockquote>

<h2 id="2-微服务">2、微服务</h2>

<p>2014，martin fowler</p>

<p>微服务：架构风格（服务微化）</p>

<p>一个应用应该是一组小型服务；可以通过HTTP的方式进行互通；</p>

<p>单体应用：ALL IN ONE</p>

<p>微服务：每一个功能元素最终都是一个可独立替换和独立升级的软件单元；</p>

<p><a href="https://martinfowler.com/articles/microservices.html#MicroservicesAndSoa">详细参照微服务文档</a></p>

<h2 id="3-环境准备">3、环境准备</h2>

<p><a href="http://www.gulixueyuan.com/">http://www.gulixueyuan.com/</a> 谷粒学院</p>

<p>环境约束</p>

<p>–jdk1.8：Spring Boot 推荐jdk1.7及以上；java version &ldquo;1.8.0_112&rdquo;</p>

<p>–maven3.x：maven 3.3以上版本；Apache Maven 3.3.9</p>

<p>–IntelliJIDEA2017：IntelliJ IDEA 2017.2.2 x64、STS</p>

<p>–SpringBoot 1.5.9.RELEASE：1.5.9；</p>

<p>统一环境；</p>

<h3 id="1-maven设置">1、MAVEN设置；</h3>

<p>给maven 的settings.xml配置文件的profiles标签添加</p>

<pre><code class="language-xml">&lt;profile&gt;
  &lt;id&gt;jdk-1.8&lt;/id&gt;
  &lt;activation&gt;
    &lt;activeByDefault&gt;true&lt;/activeByDefault&gt;
    &lt;jdk&gt;1.8&lt;/jdk&gt;
  &lt;/activation&gt;
  &lt;properties&gt;
    &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt;
    &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt;
    &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt;
  &lt;/properties&gt;
&lt;/profile&gt;
</code></pre>

<h3 id="2-idea设置">2、IDEA设置</h3>

<p>整合maven进来；</p>

<h2 id="4-spring-boot-helloworld">4、Spring Boot HelloWorld</h2>

<p>一个功能：</p>

<p>浏览器发送hello请求，服务器接受请求并处理，响应Hello World字符串；</p>

<h3 id="1-创建一个maven工程-jar">1、创建一个maven工程；（jar）</h3>

<h3 id="2-导入spring-boot相关的依赖">2、导入spring boot相关的依赖</h3>

<pre><code class="language-xml">    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;
    &lt;/parent&gt;
    &lt;dependencies&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
</code></pre>

<h3 id="3-编写一个主程序-启动spring-boot应用">3、编写一个主程序；启动Spring Boot应用</h3>

<pre><code class="language-java">/**
 *  @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用
 */
@SpringBootApplication
public class HelloWorldMainApplication {

    public static void main(String[] args) {

        // Spring应用启动起来
        SpringApplication.run(HelloWorldMainApplication.class,args);
    }
}
</code></pre>

<h3 id="4-编写相关的controller-service">4、编写相关的Controller、Service</h3>

<pre><code class="language-java">@Controller
public class HelloController {

    @ResponseBody
    @RequestMapping(&quot;/hello&quot;)
    public String hello(){
        return &quot;Hello World!&quot;;
    }
}

</code></pre>

<h3 id="5-运行主程序测试">5、运行主程序测试</h3>

<h3 id="6-简化部署">6、简化部署</h3>

<pre><code class="language-xml"> &lt;!-- 这个插件，可以将应用打包成一个可执行的jar包；--&gt;
    &lt;build&gt;
        &lt;plugins&gt;
            &lt;plugin&gt;
                &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
                &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;
            &lt;/plugin&gt;
        &lt;/plugins&gt;
    &lt;/build&gt;
</code></pre>

<p>将这个应用打成jar包，直接使用java -jar的命令进行执行；</p>

<h2 id="5-hello-world探究">5、Hello World探究</h2>

<h3 id="1-pom文件">1、POM文件</h3>

<h4 id="1-父项目">1、父项目</h4>

<pre><code class="language-xml">&lt;parent&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
    &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;
&lt;/parent&gt;

他的父项目是
&lt;parent&gt;
  &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
  &lt;artifactId&gt;spring-boot-dependencies&lt;/artifactId&gt;
  &lt;version&gt;1.5.9.RELEASE&lt;/version&gt;
  &lt;relativePath&gt;../../spring-boot-dependencies&lt;/relativePath&gt;
&lt;/parent&gt;
他来真正管理Spring Boot应用里面的所有依赖版本；

</code></pre>

<p>Spring Boot的版本仲裁中心；</p>

<p>以后我们导入依赖默认是不需要写版本；（没有在dependencies里面管理的依赖自然需要声明版本号）</p>

<h4 id="2-启动器">2、启动器</h4>

<pre><code class="language-xml">&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
    &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>

<p><strong>spring-boot-starter</strong>-==web==：</p>

<p>​   spring-boot-starter：spring-boot场景启动器；帮我们导入了web模块正常运行所依赖的组件；</p>

<p>Spring Boot将所有的功能场景都抽取出来，做成一个个的starters（启动器），只需要在项目里面引入这些starter相关场景的所有依赖都会导入进来。要用什么功能就导入什么场景的启动器</p>

<h3 id="2-主程序类-主入口类">2、主程序类，主入口类</h3>

<pre><code class="language-java">/**
 *  @SpringBootApplication 来标注一个主程序类，说明这是一个Spring Boot应用
 */
@SpringBootApplication
public class HelloWorldMainApplication {

    public static void main(String[] args) {

        // Spring应用启动起来
        SpringApplication.run(HelloWorldMainApplication.class,args);
    }
}

</code></pre>

<p>@<strong>SpringBootApplication</strong>:    Spring Boot应用标注在某个类上说明这个类是SpringBoot的主配置类，SpringBoot就应该运行这个类的main方法来启动SpringBoot应用；</p>

<pre><code class="language-java">@Target(ElementType.TYPE)
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Inherited
@SpringBootConfiguration
@EnableAutoConfiguration
@ComponentScan(excludeFilters = {
      @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class),
      @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) })
public @interface SpringBootApplication {
</code></pre>

<p>@<strong>SpringBootConfiguration</strong>:Spring Boot的配置类；</p>

<p>​       标注在某个类上，表示这是一个Spring Boot的配置类；</p>

<p>​       @<strong>Configuration</strong>:配置类上来标注这个注解；</p>

<p>​           配置类 &mdash;&ndash;  配置文件；配置类也是容器中的一个组件；@Component</p>

<p>@<strong>EnableAutoConfiguration</strong>：开启自动配置功能；</p>

<p>​       以前我们需要配置的东西，Spring Boot帮我们自动配置；@<strong>EnableAutoConfiguration</strong>告诉SpringBoot开启自动配置功能；这样自动配置才能生效；</p>

<pre><code class="language-java">@AutoConfigurationPackage
@Import(EnableAutoConfigurationImportSelector.class)
public @interface EnableAutoConfiguration {

</code></pre>

<p>​       @<strong>AutoConfigurationPackage</strong>：自动配置包</p>

<p>​       @<strong>Import</strong>(AutoConfigurationPackages.Registrar.class)：</p>

<p>​       Spring的底层注解@Import，给容器中导入一个组件；导入的组件由AutoConfigurationPackages.Registrar.class；</p>

<p>==将主配置类（@SpringBootApplication标注的类）的所在包及下面所有子包里面的所有组件扫描到Spring容器；==</p>

<p>​   @<strong>Import</strong>(EnableAutoConfigurationImportSelector.class)；</p>

<p>​       给容器中导入组件？</p>

<p>​       <strong>EnableAutoConfigurationImportSelector</strong>：导入哪些组件的选择器；</p>

<p>​       将所有需要导入的组件以全类名的方式返回；这些组件就会被添加到容器中；</p>

<p>​       会给容器中导入非常多的自动配置类（xxxAutoConfiguration）；就是给容器中导入这个场景需要的所有组件，并配置好这些组件；</p>

<p>有了自动配置类，免去了我们手动编写配置注入功能组件等的工作；</p>

<p>​       SpringFactoriesLoader.loadFactoryNames(EnableAutoConfiguration.class,classLoader)；</p>

<p>==Spring Boot在启动的时候从类路径下的META-INF/spring.factories中获取EnableAutoConfiguration指定的值，将这些值作为自动配置类导入到容器中，自动配置类就生效，帮我们进行自动配置工作；==以前我们需要自己配置的东西，自动配置类都帮我们；</p>

<p>J2EE的整体整合解决方案和自动配置都在spring-boot-autoconfigure-1.5.9.RELEASE.jar；</p>

<h2 id="6-使用spring-initializer快速创建spring-boot项目">6、使用Spring Initializer快速创建Spring Boot项目</h2>

<h3 id="1-idea-使用-spring-initializer快速创建项目">1、IDEA：使用 Spring Initializer快速创建项目</h3>

<p>IDE都支持使用Spring的项目创建向导快速创建一个Spring Boot项目；</p>

<p>选择我们需要的模块；向导会联网创建Spring Boot项目；</p>

<p>默认生成的Spring Boot项目；</p>

<ul>
<li>主程序已经生成好了，我们只需要我们自己的逻辑</li>
<li>resources文件夹中目录结构

<ul>
<li>static：保存所有的静态资源； js css  images；</li>
<li>templates：保存所有的模板页面；（Spring Boot默认jar包使用嵌入式的Tomcat，默认不支持JSP页面）；可以使用模板引擎（freemarker、thymeleaf）；</li>
<li>application.properties：Spring Boot应用的配置文件；可以修改一些默认设置；</li>
</ul></li>
</ul>

<h3 id="2-sts使用-spring-starter-project快速创建项目">2、STS使用 Spring Starter Project快速创建项目</h3>

<hr />

<h1 id="二-配置文件">二、配置文件</h1>

<h2 id="1-配置文件">1、配置文件</h2>

<p>SpringBoot使用一个全局的配置文件，配置文件名是固定的；</p>

<p>•application.properties</p>

<p>•application.yml</p>

<p>配置文件的作用：修改SpringBoot自动配置的默认值；SpringBoot在底层都给我们自动配置好；</p>

<p>YAML（YAML Ain&rsquo;t Markup Language）</p>

<p>​   YAML  A Markup Language：是一个标记语言</p>

<p>​   YAML   isn&rsquo;t Markup Language：不是一个标记语言；</p>

<p>标记语言：</p>

<p>​   以前的配置文件；大多都使用的是  <strong>xxxx.xml</strong>文件；</p>

<p>​   YAML：<strong>以数据为中心</strong>，比json、xml等更适合做配置文件；</p>

<p>​   YAML：配置例子</p>

<pre><code class="language-yaml">server:
  port: 8081
</code></pre>

<p>​   XML：</p>

<pre><code class="language-xml">&lt;server&gt;
	&lt;port&gt;8081&lt;/port&gt;
&lt;/server&gt;
</code></pre>

<h2 id="2-yaml语法">2、YAML语法：</h2>

<h3 id="1-基本语法">1、基本语法</h3>

<p>k:(空格)v：表示一对键值对（空格必须有）；</p>

<p>以<strong>空格</strong>的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的</p>

<pre><code class="language-yaml">server:
    port: 8081
    path: /hello
</code></pre>

<p>属性和值也是大小写敏感；</p>

<h3 id="2-值的写法">2、值的写法</h3>

<h4 id="字面量-普通的值-数字-字符串-布尔">字面量：普通的值（数字，字符串，布尔）</h4>

<p>​   k: v：字面直接来写；</p>

<p>​       字符串默认不用加上单引号或者双引号；</p>

<p>​       &ldquo;&ldquo;：双引号；不会转义字符串里面的特殊字符；特殊字符会作为本身想表示的意思</p>

<p>​               name:   &ldquo;zhangsan \n lisi&rdquo;：输出；zhangsan 换行  lisi</p>

<p>​       &ldquo;：单引号；会转义特殊字符，特殊字符最终只是一个普通的字符串数据</p>

<p>​               name:   ‘zhangsan \n lisi’：输出；zhangsan \n  lisi</p>

<h4 id="对象-map-属性和值-键值对">对象、Map（属性和值）（键值对）：</h4>

<p>​   k: v：在下一行来写对象的属性和值的关系；注意缩进</p>

<p>​       对象还是k: v的方式</p>

<pre><code class="language-yaml">friends:
		lastName: zhangsan
		age: 20

</code></pre>

<p>行内写法：</p>

<pre><code class="language-yaml">friends: {lastName: zhangsan,age: 18}

</code></pre>

<h4 id="数组-list-set">数组（List、Set）：</h4>

<p>用- 值表示数组中的一个元素</p>

<pre><code class="language-yaml">pets:
 - cat
 - dog
 - pig

</code></pre>

<p>行内写法</p>

<pre><code class="language-yaml">pets: [cat,dog,pig]

</code></pre>

<h2 id="3-配置文件值注入">3、配置文件值注入</h2>

<p>配置文件</p>

<pre><code class="language-yaml">person:
    lastName: hello
    age: 18
    boss: false
    birth: 2017/12/12
    maps: {k1: v1,k2: 12}
    lists:
      - lisi
      - zhaoliu
    dog:
      name: 小狗
      age: 12

</code></pre>

<p>javaBean：</p>

<pre><code class="language-java">/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；
 *      prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射
 *
 * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；
 *
 */
@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
public class Person {

    private String lastName;
    private Integer age;
    private Boolean boss;
    private Date birth;

    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;


</code></pre>

<p>我们可以导入配置文件处理器，以后编写配置就有提示了</p>

<pre><code class="language-xml">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;
		&lt;dependency&gt;
			&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
			&lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;
			&lt;optional&gt;true&lt;/optional&gt;
		&lt;/dependency&gt;

</code></pre>

<h4 id="1-properties配置文件在idea中默认utf-8可能会乱码">1、properties配置文件在idea中默认utf-8可能会乱码</h4>

<p>调整</p>

<h4 id="2-value获取值和-configurationproperties获取值比较">2、@Value获取值和@ConfigurationProperties获取值比较</h4>

<table>
<thead>
<tr>
<th></th>
<th>@ConfigurationProperties</th>
<th>@Value</th>
</tr>
</thead>

<tbody>
<tr>
<td>功能</td>
<td>批量注入配置文件中的属性</td>
<td>一个个指定</td>
</tr>

<tr>
<td>松散绑定（松散语法）</td>
<td>支持</td>
<td>不支持</td>
</tr>

<tr>
<td>SpEL</td>
<td>不支持</td>
<td>支持</td>
</tr>

<tr>
<td>JSR303数据校验</td>
<td>支持</td>
<td>不支持</td>
</tr>

<tr>
<td>复杂类型封装</td>
<td>支持</td>
<td>不支持</td>
</tr>
</tbody>
</table>

<p>配置文件yml还是properties他们都能获取到值；</p>

<p>如果说，我们只是在某个业务逻辑中需要获取一下配置文件中的某项值，使用@Value；</p>

<p>如果说，我们专门编写了一个javaBean来和配置文件进行映射，我们就直接使用@ConfigurationProperties；</p>

<h4 id="3-配置文件注入值数据校验">3、配置文件注入值数据校验</h4>

<pre><code class="language-java">@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
@Validated
public class Person {

    /**
     * &lt;bean class=&quot;Person&quot;&gt;
     *      &lt;property name=&quot;lastName&quot; value=&quot;字面量/${key}从环境变量、配置文件中获取值/#{SpEL}&quot;&gt;&lt;/property&gt;
     * &lt;bean/&gt;
     */

   //lastName必须是邮箱格式
    @Email
    //@Value(&quot;${person.last-name}&quot;)
    private String lastName;
    //@Value(&quot;#{11*2}&quot;)
    private Integer age;
    //@Value(&quot;true&quot;)
    private Boolean boss;

    private Date birth;
    private Map&lt;String,Object&gt; maps;
    private List&lt;Object&gt; lists;
    private Dog dog;

</code></pre>

<h4 id="4-propertysource-importresource-bean">4、@PropertySource&amp;@ImportResource&amp;@Bean</h4>

<p>@<strong>PropertySource</strong>：加载指定的配置文件；</p>

<pre><code class="language-java">/**
 * 将配置文件中配置的每一个属性的值，映射到这个组件中
 * @ConfigurationProperties：告诉SpringBoot将本类中的所有属性和配置文件中相关的配置进行绑定；
 *      prefix = &quot;person&quot;：配置文件中哪个下面的所有属性进行一一映射
 *
 * 只有这个组件是容器中的组件，才能容器提供的@ConfigurationProperties功能；
 *  @ConfigurationProperties(prefix = &quot;person&quot;)默认从全局配置文件中获取值；
 *
 */
@PropertySource(value = {&quot;classpath:person.properties&quot;})
@Component
@ConfigurationProperties(prefix = &quot;person&quot;)
//@Validated
public class Person {

    /**
     * &lt;bean class=&quot;Person&quot;&gt;
     *      &lt;property name=&quot;lastName&quot; value=&quot;字面量/${key}从环境变量、配置文件中获取值/#{SpEL}&quot;&gt;&lt;/property&gt;
     * &lt;bean/&gt;
     */

   //lastName必须是邮箱格式
   // @Email
    //@Value(&quot;${person.last-name}&quot;)
    private String lastName;
    //@Value(&quot;#{11*2}&quot;)
    private Integer age;
    //@Value(&quot;true&quot;)
    private Boolean boss;


</code></pre>

<p>@<strong>ImportResource</strong>：导入Spring的配置文件，让配置文件里面的内容生效；</p>

<p>Spring Boot里面没有Spring的配置文件，我们自己编写的配置文件，也不能自动识别；</p>

<p>想让Spring的配置文件生效，加载进来；@<strong>ImportResource</strong>标注在一个配置类上</p>

<pre><code class="language-java">@ImportResource(locations = {&quot;classpath:beans.xml&quot;})
导入Spring的配置文件让其生效

</code></pre>

<p>不来编写Spring的配置文件</p>

<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
       xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
       xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;&gt;


    &lt;bean id=&quot;helloService&quot; class=&quot;com.atguigu.springboot.service.HelloService&quot;&gt;&lt;/bean&gt;
&lt;/beans&gt;
</code></pre>

<p>SpringBoot推荐给容器中添加组件的方式；推荐使用全注解的方式</p>

<p>1、配置类<strong>@Configuration</strong>&mdash;&mdash;&gt;Spring配置文件</p>

<p>2、使用<strong>@Bean</strong>给容器中添加组件</p>

<pre><code class="language-java">/**
 * @Configuration：指明当前类是一个配置类；就是来替代之前的Spring配置文件
 *
 * 在配置文件中用&lt;bean&gt;&lt;bean/&gt;标签添加组件
 *
 */
@Configuration
public class MyAppConfig {

    //将方法的返回值添加到容器中；容器中这个组件默认的id就是方法名
    @Bean
    public HelloService helloService02(){
        System.out.println(&quot;配置类@Bean给容器中添加组件了...&quot;);
        return new HelloService();
    }
}
</code></pre>

<p>##4、配置文件占位符</p>

<h3 id="1-随机数">1、随机数</h3>

<pre><code class="language-java">${random.value}、${random.int}、${random.long}
${random.int(10)}、${random.int[1024,65536]}


</code></pre>

<h3 id="2-占位符获取之前配置的值-如果没有可以是用-指定默认值">2、占位符获取之前配置的值，如果没有可以是用:指定默认值</h3>

<pre><code class="language-properties">person.last-name=张三${random.uuid}
person.age=${random.int}
person.birth=2017/12/15
person.boss=false
person.maps.k1=v1
person.maps.k2=14
person.lists=a,b,c
person.dog.name=${person.hello:hello}_dog
person.dog.age=15
</code></pre>

<h2 id="5-profile">5、Profile</h2>

<h3 id="1-多profile文件">1、多Profile文件</h3>

<p>我们在主配置文件编写的时候，文件名可以是   application-{profile}.properties/yml</p>

<p>默认使用application.properties的配置；</p>

<h3 id="2-yml支持多文档块方式">2、yml支持多文档块方式</h3>

<pre><code class="language-yml">server:
  port: 8081
spring:
  profiles:
    active: prod

---
server:
  port: 8083
spring:
  profiles: dev


---

server:
  port: 8084
spring:
  profiles: prod  #指定属于哪个环境
</code></pre>

<h3 id="3-激活指定profile">3、激活指定profile</h3>

<p>​   1、在配置文件中指定  spring.profiles.active=dev</p>

<p>​   2、命令行：</p>

<p>​       java -jar spring-boot-02-config-0.0.1-SNAPSHOT.jar &ndash;spring.profiles.active=dev；</p>

<p>​       可以直接在测试的时候，配置传入命令行参数</p>

<p>​   3、虚拟机参数；</p>

<p>​       -Dspring.profiles.active=dev</p>

<h2 id="6-配置文件加载位置">6、配置文件加载位置</h2>

<p>springboot 启动会扫描以下位置的application.properties或者application.yml文件作为Spring boot的默认配置文件</p>

<p>–file:./config/</p>

<p>–file:./</p>

<p>–classpath:/config/</p>

<p>–classpath:/</p>

<p>优先级由高到底，高优先级的配置会覆盖低优先级的配置；</p>

<p>SpringBoot会从这四个位置全部加载主配置文件；<strong>互补配置</strong>；</p>

<p>==我们还可以通过spring.config.location来改变默认的配置文件位置==</p>

<p><strong>项目打包好以后，我们可以使用命令行参数的形式，启动项目的时候来指定配置文件的新位置；指定配置文件和默认加载的这些配置文件共同起作用形成互补配置；</strong></p>

<p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar &ndash;spring.config.location=G:/application.properties</p>

<h2 id="7-外部配置加载顺序">7、外部配置加载顺序</h2>

<p><strong>==SpringBoot也可以从以下位置加载配置； 优先级从高到低；高优先级的配置覆盖低优先级的配置，所有的配置会形成互补配置==</strong></p>

<p><strong>1.命令行参数</strong></p>

<p>所有的配置都可以在命令行上进行指定</p>

<p>java -jar spring-boot-02-config-02-0.0.1-SNAPSHOT.jar &ndash;server.port=8087  &ndash;server.context-path=/abc</p>

<p>多个配置用空格分开； &ndash;配置项=值</p>

<p>2.来自java:comp/env的JNDI属性</p>

<p>3.Java系统属性（System.getProperties()）</p>

<p>4.操作系统环境变量</p>

<p>5.RandomValuePropertySource配置的random.*属性值</p>

<p>==<strong>由jar包外向jar包内进行寻找；</strong>==</p>

<p>==<strong>优先加载带profile</strong>==</p>

<p><strong>6.jar包外部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p>

<p><strong>7.jar包内部的application-{profile}.properties或application.yml(带spring.profile)配置文件</strong></p>

<p>==<strong>再来加载不带profile</strong>==</p>

<p><strong>8.jar包外部的application.properties或application.yml(不带spring.profile)配置文件</strong></p>

<p><strong>9.jar包内部的application.properties或application.yml(不带spring.profile)配置文件</strong></p>

<p>10.@Configuration注解类上的@PropertySource</p>

<p>11.通过SpringApplication.setDefaultProperties指定的默认属性</p>

<p>所有支持的配置加载来源；</p>

<p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#boot-features-external-config">参考官方文档</a></p>

<h2 id="8-自动配置原理">8、自动配置原理</h2>

<p>配置文件到底能写什么？怎么写？自动配置原理；</p>

<p><a href="https://docs.spring.io/spring-boot/docs/1.5.9.RELEASE/reference/htmlsingle/#common-application-properties">配置文件能配置的属性参照</a></p>

<h3 id="1-自动配置原理">1、<strong>自动配置原理：</strong></h3>

<p>1）、SpringBoot启动的时候加载主配置类，开启了自动配置功能 ==@EnableAutoConfiguration==</p>

<p><strong>2）、@EnableAutoConfiguration 作用：</strong></p>

<ul>
<li><p>利用EnableAutoConfigurationImportSelector给容器中导入一些组件？</p></li>

<li><p>可以查看selectImports()方法的内容；</p></li>

<li><p>List<String> configurations = getCandidateConfigurations(annotationMetadata,      attributes);获取候选的配置</p>

<ul>
<li><pre><code class="language-java">SpringFactoriesLoader.loadFactoryNames()
扫描所有jar包类路径下  META-INF/spring.factories
把扫描到的这些文件的内容包装成properties对象
从properties中获取到EnableAutoConfiguration.class类（类名）对应的值，然后把他们添加在容器中
    
    
</code></pre></li>
</ul>

<p><strong>==将 类路径下  META-INF/spring.factories 里面配置的所有EnableAutoConfiguration的值加入到了容器中；==</strong></p>

<p>```java</p></li>
</ul>

<h1 id="auto-configure">Auto Configure</h1>

<p>org.springframework.boot.autoconfigure.EnableAutoConfiguration=<br />
org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,<br />
org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,<br />
org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,<br />
org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,<br />
org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,<br />
org.springframework.boot.autoconfigure.cassandra.CassandraAutoConfiguration,<br />
org.springframework.boot.autoconfigure.cloud.CloudAutoConfiguration,<br />
org.springframework.boot.autoconfigure.context.ConfigurationPropertiesAutoConfiguration,<br />
org.springframework.boot.autoconfigure.context.MessageSourceAutoConfiguration,<br />
org.springframework.boot.autoconfigure.context.PropertyPlaceholderAutoConfiguration,<br />
org.springframework.boot.autoconfigure.couchbase.CouchbaseAutoConfiguration,<br />
org.springframework.boot.autoconfigure.dao.PersistenceExceptionTranslationAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.cassandra.CassandraDataAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.cassandra.CassandraRepositoriesAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseDataAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.couchbase.CouchbaseRepositoriesAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchDataAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.elasticsearch.ElasticsearchRepositoriesAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.jpa.JpaRepositoriesAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.ldap.LdapDataAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.ldap.LdapRepositoriesAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.mongo.MongoDataAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.mongo.MongoRepositoriesAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.neo4j.Neo4jDataAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.neo4j.Neo4jRepositoriesAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.solr.SolrRepositoriesAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.redis.RedisAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.redis.RedisRepositoriesAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.rest.RepositoryRestMvcAutoConfiguration,<br />
org.springframework.boot.autoconfigure.data.web.SpringDataWebAutoConfiguration,<br />
org.springframework.boot.autoconfigure.elasticsearch.jest.JestAutoConfiguration,<br />
org.springframework.boot.autoconfigure.freemarker.FreeMarkerAutoConfiguration,<br />
org.springframework.boot.autoconfigure.gson.GsonAutoConfiguration,<br />
org.springframework.boot.autoconfigure.h2.H2ConsoleAutoConfiguration,<br />
org.springframework.boot.autoconfigure.hateoas.HypermediaAutoConfiguration,<br />
org.springframework.boot.autoconfigure.hazelcast.HazelcastAutoConfiguration,<br />
org.springframework.boot.autoconfigure.hazelcast.HazelcastJpaDependencyAutoConfiguration,<br />
org.springframework.boot.autoconfigure.info.ProjectInfoAutoConfiguration,<br />
org.springframework.boot.autoconfigure.integration.IntegrationAutoConfiguration,<br />
org.springframework.boot.autoconfigure.jackson.JacksonAutoConfiguration,<br />
org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration,<br />
org.springframework.boot.autoconfigure.jdbc.JdbcTemplateAutoConfiguration,<br />
org.springframework.boot.autoconfigure.jdbc.JndiDataSourceAutoConfiguration,<br />
org.springframework.boot.autoconfigure.jdbc.XADataSourceAutoConfiguration,<br />
org.springframework.boot.autoconfigure.jdbc.DataSourceTransactionManagerAutoConfiguration,<br />
org.springframework.boot.autoconfigure.jms.JmsAutoConfiguration,<br />
org.springframework.boot.autoconfigure.jmx.JmxAutoConfiguration,<br />
org.springframework.boot.autoconfigure.jms.JndiConnectionFactoryAutoConfiguration,<br />
org.springframework.boot.autoconfigure.jms.activemq.ActiveMQAutoConfiguration,<br />
org.springframework.boot.autoconfigure.jms.artemis.ArtemisAutoConfiguration,<br />
org.springframework.boot.autoconfigure.flyway.FlywayAutoConfiguration,<br />
org.springframework.boot.autoconfigure.groovy.template.GroovyTemplateAutoConfiguration,<br />
org.springframework.boot.autoconfigure.jersey.JerseyAutoConfiguration,<br />
org.springframework.boot.autoconfigure.jooq.JooqAutoConfiguration,<br />
org.springframework.boot.autoconfigure.kafka.KafkaAutoConfiguration,<br />
org.springframework.boot.autoconfigure.ldap.embedded.EmbeddedLdapAutoConfiguration,<br />
org.springframework.boot.autoconfigure.ldap.LdapAutoConfiguration,<br />
org.springframework.boot.autoconfigure.liquibase.LiquibaseAutoConfiguration,<br />
org.springframework.boot.autoconfigure.mail.MailSenderAutoConfiguration,<br />
org.springframework.boot.autoconfigure.mail.MailSenderValidatorAutoConfiguration,<br />
org.springframework.boot.autoconfigure.mobile.DeviceResolverAutoConfiguration,<br />
org.springframework.boot.autoconfigure.mobile.DeviceDelegatingViewResolverAutoConfiguration,<br />
org.springframework.boot.autoconfigure.mobile.SitePreferenceAutoConfiguration,<br />
org.springframework.boot.autoconfigure.mongo.embedded.EmbeddedMongoAutoConfiguration,<br />
org.springframework.boot.autoconfigure.mongo.MongoAutoConfiguration,<br />
org.springframework.boot.autoconfigure.mustache.MustacheAutoConfiguration,<br />
org.springframework.boot.autoconfigure.orm.jpa.HibernateJpaAutoConfiguration,<br />
org.springframework.boot.autoconfigure.reactor.ReactorAutoConfiguration,<br />
org.springframework.boot.autoconfigure.security.SecurityAutoConfiguration,<br />
org.springframework.boot.autoconfigure.security.SecurityFilterAutoConfiguration,<br />
org.springframework.boot.autoconfigure.security.FallbackWebSecurityAutoConfiguration,<br />
org.springframework.boot.autoconfigure.security.oauth2.OAuth2AutoConfiguration,<br />
org.springframework.boot.autoconfigure.sendgrid.SendGridAutoConfiguration,<br />
org.springframework.boot.autoconfigure.session.SessionAutoConfiguration,<br />
org.springframework.boot.autoconfigure.social.SocialWebAutoConfiguration,<br />
org.springframework.boot.autoconfigure.social.FacebookAutoConfiguration,<br />
org.springframework.boot.autoconfigure.social.LinkedInAutoConfiguration,<br />
org.springframework.boot.autoconfigure.social.TwitterAutoConfiguration,<br />
org.springframework.boot.autoconfigure.solr.SolrAutoConfiguration,<br />
org.springframework.boot.autoconfigure.thymeleaf.ThymeleafAutoConfiguration,<br />
org.springframework.boot.autoconfigure.transaction.TransactionAutoConfiguration,<br />
org.springframework.boot.autoconfigure.transaction.jta.JtaAutoConfiguration,<br />
org.springframework.boot.autoconfigure.validation.ValidationAutoConfiguration,<br />
org.springframework.boot.autoconfigure.web.DispatcherServletAutoConfiguration,<br />
org.springframework.boot.autoconfigure.web.EmbeddedServletContainerAutoConfiguration,<br />
org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration,<br />
org.springframework.boot.autoconfigure.web.HttpEncodingAutoConfiguration,<br />
org.springframework.boot.autoconfigure.web.HttpMessageConvertersAutoConfiguration,<br />
org.springframework.boot.autoconfigure.web.MultipartAutoConfiguration,<br />
org.springframework.boot.autoconfigure.web.ServerPropertiesAutoConfiguration,<br />
org.springframework.boot.autoconfigure.web.WebClientAutoConfiguration,<br />
org.springframework.boot.autoconfigure.web.WebMvcAutoConfiguration,<br />
org.springframework.boot.autoconfigure.websocket.WebSocketAutoConfiguration,<br />
org.springframework.boot.autoconfigure.websocket.WebSocketMessagingAutoConfiguration,<br />
org.springframework.boot.autoconfigure.webservices.WebServicesAutoConfiguration</p>

<pre><code>


每一个这样的  xxxAutoConfiguration类都是容器中的一个组件，都加入到容器中；用他们来做自动配置；

3）、每一个自动配置类进行自动配置功能；

4）、以**HttpEncodingAutoConfiguration（Http编码自动配置）**为例解释自动配置原理；



</code></pre>

<p>java
@Configuration   //表示这是一个配置类，以前编写的配置文件一样，也可以给容器中添加组件
@EnableConfigurationProperties(HttpEncodingProperties.class)  //启动指定类的ConfigurationProperties功能；将配置文件中对应的值和HttpEncodingProperties绑定起来；并把HttpEncodingProperties加入到ioc容器中</p>

<p>@ConditionalOnWebApplication //Spring底层@Conditional注解（Spring注解版），根据不同的条件，如果满足指定的条件，整个配置类里面的配置就会生效；    判断当前应用是否是web应用，如果是，当前配置类生效</p>

<p>@ConditionalOnClass(CharacterEncodingFilter.class)  //判断当前项目有没有这个类CharacterEncodingFilter；SpringMVC中进行乱码解决的过滤器；</p>

<p>@ConditionalOnProperty(prefix = &ldquo;spring.http.encoding&rdquo;, value = &ldquo;enabled&rdquo;, matchIfMissing = true)  //判断配置文件中是否存在某个配置  spring.http.encoding.enabled；如果不存在，判断也是成立的
//即使我们配置文件中不配置pring.http.encoding.enabled=true，也是默认生效的；
public class HttpEncodingAutoConfiguration {</p>

<p>	//他已经和SpringBoot的配置文件映射了
  	private final HttpEncodingProperties properties;</p>

<p>//只有一个有参构造器的情况下，参数的值就会从容器中拿
  	public HttpEncodingAutoConfiguration(HttpEncodingProperties properties) {
		this.properties = properties;
	}</p>

<pre><code>@Bean   //给容器中添加一个组件，这个组件的某些值需要从properties中获取
</code></pre>

<p>	@ConditionalOnMissingBean(CharacterEncodingFilter.class) //判断容器没有这个组件？
	public CharacterEncodingFilter characterEncodingFilter() {
		CharacterEncodingFilter filter = new OrderedCharacterEncodingFilter();
		filter.setEncoding(this.properties.getCharset().name());
		filter.setForceRequestEncoding(this.properties.shouldForce(Type.REQUEST));
		filter.setForceResponseEncoding(this.properties.shouldForce(Type.RESPONSE));
		return filter;
	}</p>

<pre><code>
根据当前不同的条件判断，决定这个配置类是否生效？

一但这个配置类生效；这个配置类就会给容器中添加各种组件；这些组件的属性是从对应的properties类中获取的，这些类里面的每一个属性又是和配置文件绑定的；







5）、所有在配置文件中能配置的属性都是在xxxxProperties类中封装者‘；配置文件能配置什么就可以参照某个功能对应的这个属性类

</code></pre>

<p>java
@ConfigurationProperties(prefix = &ldquo;spring.http.encoding&rdquo;)  //从配置文件中获取指定的值和bean的属性进行绑定
public class HttpEncodingProperties {</p>

<p>public static final Charset DEFAULT_CHARSET = Charset.forName(&ldquo;UTF-8&rdquo;);</p>

<pre><code>




**精髓：**

​   **1）、SpringBoot启动会加载大量的自动配置类**

​   **2）、我们看我们需要的功能有没有SpringBoot默认写好的自动配置类；**

​   **3）、我们再来看这个自动配置类中到底配置了哪些组件；（只要我们要用的组件有，我们就不需要再来配置了）**

​   **4）、给容器中自动配置类添加组件的时候，会从properties类中获取某些属性。我们就可以在配置文件中指定这些属性的值；**



xxxxAutoConfigurartion：自动配置类；

给容器中添加组件

xxxxProperties:封装配置文件中相关属性；



### 2、细节



#### 1、@Conditional派生注解（Spring注解版原生的@Conditional作用）

作用：必须是@Conditional指定的条件成立，才给容器中添加组件，配置配里面的所有内容才生效；

| @Conditional扩展注解            | 作用（判断是否满足当前指定条件）                 |
| ------------------------------- | ------------------------------------------------ |
| @ConditionalOnJava              | 系统的java版本是否符合要求                       |
| @ConditionalOnBean              | 容器中存在指定Bean；                             |
| @ConditionalOnMissingBean       | 容器中不存在指定Bean；                           |
| @ConditionalOnExpression        | 满足SpEL表达式指定                               |
| @ConditionalOnClass             | 系统中有指定的类                                 |
| @ConditionalOnMissingClass      | 系统中没有指定的类                               |
| @ConditionalOnSingleCandidate   | 容器中只有一个指定的Bean，或者这个Bean是首选Bean |
| @ConditionalOnProperty          | 系统中指定的属性是否有指定的值                   |
| @ConditionalOnResource          | 类路径下是否存在指定资源文件                     |
| @ConditionalOnWebApplication    | 当前是web环境                                    |
| @ConditionalOnNotWebApplication | 当前不是web环境                                  |
| @ConditionalOnJndi              | JNDI存在指定项                                   |

**自动配置类必须在一定的条件下才能生效；**

我们怎么知道哪些自动配置类生效；

**==我们可以通过启用  debug=true属性；来让控制台打印自动配置报告==**，这样我们就可以很方便的知道哪些自动配置类生效；

</code></pre>

<h1 id="java">java</h1>

<h1 id="auto-configuration-report">AUTO-CONFIGURATION REPORT</h1>

<h2 id="positive-matches-自动配置类启用的">Positive matches:（自动配置类启用的）</h2>

<p>DispatcherServletAutoConfiguration matched:
      - @ConditionalOnClass found required class &lsquo;org.springframework.web.servlet.DispatcherServlet&rsquo;; @ConditionalOnMissingClass did not find unwanted class (OnClassCondition)
      - @ConditionalOnWebApplication (required) found StandardServletEnvironment (OnWebApplicationCondition)</p>

<h2 id="negative-matches-没有启动-没有匹配成功的自动配置类">Negative matches:（没有启动，没有匹配成功的自动配置类）</h2>

<p>ActiveMQAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required classes &lsquo;javax.jms.ConnectionFactory&rsquo;, &lsquo;org.apache.activemq.ActiveMQConnectionFactory&rsquo; (OnClassCondition)</p>

<p>AopAutoConfiguration:
      Did not match:
         - @ConditionalOnClass did not find required classes &lsquo;org.aspectj.lang.annotation.Aspect&rsquo;, &lsquo;org.aspectj.lang.reflect.Advice&rsquo; (OnClassCondition)</p>

<p>```</p>


    
  </section>
  <div class="divider my-gap"></div>
  <footer class="col-12 d-inline-block">
    <span class="float-left">
      <button class="btn btn-action btn-accent shadow s-circle" onclick="window.history.back();"><i class="fas fa-arrow-left"></i></button>
    </span>
    <span class="float-right">
      <div class="text-right float-left mx-2">
        <span class="text-dark">rui</span><br>
        <span class="text-gray">黑丑</span>
      </div>
      <figure class="avatar avatar-lg">
        <img id="profile">
      </figure>
    </span>
  </footer>
</article>

    <footer class="container p-centered text-center my-gap">
  
    <div class="container">

  
    <a class="symbol" href="mailto:dongr12138@gmail.com" target="_blank"><i class="fas fa-envelope"></i>
  
  </a>

  
    <a class="symbol" href="https://github.com/dongr12138/dongr12138.github.io/" target="_blank"><i class="fab fa-github"></i>
  
  </a>

</div>

  

  <small class="text-gray">
  
    © Copyright 2019 rui
  
  </small>
</footer>

  </div>
  </section>
  <script src="//ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js"></script>
<script src="https://dongr12138.github.io/js/main.js"></script>
<script src="https://dongr12138.github.io/js/highlight.js"></script>
<script>hljs.initHighlightingOnLoad();</script>





</body>
</html>
